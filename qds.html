<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Quantization, Dithering, and Noise Shaping</title>
  <script src="https://unpkg.com/audioworklet-polyfill/dist/audioworklet-polyfill.js"></script>
</head>
<body>
  <div>
    <table border="0" style="width: 500px;">
      <tr>
        <td width="33%"><input type="button" value="Audio 1" id="audio1" style="width: 100%;" /></td>
        <td width="33%"><input type="button" value="Audio 2" id="audio2" style="width: 100%;" /></td>
        <td width="33%"><input type="button" value="Start" id="start" style="width: 100%;" /></td>
      </tr>
      <tr>
        <td colspan="2"><input type="file" id="file-input" accept="audio/*" style="width: 100%;" /></td>
        <td><input type="button" value="Stop" id="stop" style="width: 100%;" /></td>
      </tr>
    </table>
  </div>
  <div id="graph" style="width: 500px; height: 200px;">
    <canvas id="axiscanvas" width="500" height="200"
      style="position: absolute; z-index: 1" ></canvas>
    <canvas id="funccanvas" width="500" height="200"
      style="position: absolute; z-index: 2" ></canvas>
    <canvas id="cursorcanvas" width="500" height="200"
      style="position: absolute; z-index: 3" ></canvas>
  </div>
  <div style="width: 500px; height: 220px;" align="center" >
    <img src="images/qds/ns5.png" id="diagram" />
  </div>
  <div>
    <table border="0" style="width: 500px;">
      <tr>
        <td><input id="linear" type="checkbox" />linear</td>
        <td>Quantization</td>
        <td><input id="dither" type="checkbox" />Dither</td>
        <td><input id="noiseshaping" type="checkbox" />Noise-shaping</td>
      </tr>
      <tr>
        <td><input id="wave" type="checkbox" />Wave</td>
        <td><select id="wordlength">
          <option value="16">16</option>
          <option value="10">10</option>
          <option value="8">8</option>
          <option value="6">6</option>
          <option value="4">4</option>
          <option value="2">2</option>
        </select></td>
        <td><select id="dithertype">
          <option value="rect">rectangular</option>
          <option value="tri">triangular</option>
          <option value="hp">high-pass</option>
        </select></td>
        <td><select id="noiseshapingfilter">
          <option value="1">First Order</option>
          <option value="2">Second Order</option>
          <option value="3">Psychoacoustic3</option>
          <option value="5">Psychoacoustic5</option>
          <option value="9">Psychoacoustic9</option>
        </select></td>
      </tr>
    </table>
  </div>
  <br />
  <div style="width: 600px">
  This script demonstrates audio effects resulting from <b>Quantization</b>. It
  is designed for a first insight into the perceptual effects of quantizing an
  audio signal.
  <p>The following functions can be selected on the lower right of the graphical
     user interface</p>
  <ul>
    <li> <b>Quantizer&nbsp;</b>
      <ul>
        <li>word length w leads to quantization step size Q=2^(w-1)<br>
        </li>
      </ul>
    </li>
    <li><b>Dither</b>
      <ul>
        <li>rect dither - uniform probability density function </li>
        <li>tri dither - triangular probability density function</li>
        <li>high-pass dither - triangular probability density function and
          high-pass power spectral density</li>
      </ul>
    </li>
    <li><b>Noise shaping</b>
      <ul>
        <li>first-order H(z)=z^(-1)</li>
        <li>second-order H(z)=-2z^(-1)+z^(-2)</li>
        <li>psychoacoustic noise shaping<br>
        </li>
      </ul>
    </li>
  </ul>
  <p>You can choose between two predefined audio files from our web-server
    ("audio1.wav" or "audio2.wav") or your own local .wav-file to be
    processed.</p>
  <p>Audio2 is licensed under <a href="https://creativecommons.org/licenses/by/3.0/">CC-BY-3.0</a> by <a href="https://soundcloud.com/unfinite">unfinite</a></p>
</div>
<script>
"use strict";

if (Math.log10 === undefined) {
  Math.log10 = function(x) { return  Math.LOG10E * Math.log(x); };
}

var makeFunctionGraph = function(axisid, funcid) {
  var fgcanvas = document.getElementById(funcid);
  var width = fgcanvas.width;
  var height = fgcanvas.height;
  var fgctx = fgcanvas.getContext("2d");

  var logx = true;
  var xmax = 20000;
  var xmin = 50;

  var ymax = 0;
  var ymin = -80;

  var xoffset = 25;
  var yoffset = 25;

  var x_pos_to_val_lin = function(x) {
    return (xmax-xmin) * (x-xoffset) / (width-xoffset) + xmin;
  };

  var x_pos_to_val_log = function(x) {
    return xmin * Math.pow(10, Math.log10(xmax/xmin) * (x-xoffset) / (width-xoffset));
  };

  var x_pos_to_val = x_pos_to_val_log;

  var x_val_to_pos_lin = function(x) {
    return (x - xmin) * (width-xoffset) / xmax + xoffset;
  };

  var x_val_to_pos_log = function(x) {
    return Math.log10(x / xmin) / Math.log10(xmax/xmin) * (width-xoffset) + xoffset;
  };

  var x_val_to_pos = x_val_to_pos_log;

  var set_logx = function(_logx) {
    logx = _logx;
    if (logx) {
      x_pos_to_val = x_pos_to_val_log;
      x_val_to_pos = x_val_to_pos_log;
    } else {
      x_pos_to_val = x_pos_to_val_lin;
      x_val_to_pos = x_val_to_pos_lin;
    }
    drawAxis();
  }

  var y_val_to_pos = function (y) {
    return 10 + (height-10-yoffset) / (ymin-ymax) * (y-ymax);
  };

  var niceCeil = function (x) {
    var f = Math.pow(10, Math.floor(Math.log10(x)));
    x /= f;
    if (x > 5) {
      x = 10;
    } else if (x > 2) {
      x = 5;
    } else if (x > 1) {
      x = 2;
    }
    return x * f;
  }

  var drawAxis = function() {
    var canvas = document.getElementById(axisid);
    var ctx = canvas.getContext("2d");
    ctx.clearRect(0, 0, width, height);
    //ctx.font = '10px sans-serif';
    ctx.textBaseline = 'middle';
    ctx.textAlign = 'end';
    var xstep = niceCeil((xmax-xmin) / (width-xoffset) * 30);
    var ystep = niceCeil((ymax-ymin) / (height-yoffset-10) * 20);
    for (var y=Math.floor(ymax/ystep)*ystep; y >= ymin; y -= ystep) {
      ctx.strokeStyle = 'rgb(0, 0, 0)';
      ctx.strokeText(y, xoffset-2, y_val_to_pos(y));
      ctx.strokeStyle = 'rgb(100, 100, 100)';
    }
    ctx.textBaseline = 'top';
    ctx.textAlign = 'center';
    if (logx) {
      ctx.strokeStyle = 'rgb(0, 0, 0)';
      for (var x=Math.pow(10, Math.ceil(Math.log10(xmin))); x <= xmax; x *= 10) {
        ctx.strokeText(x, x_val_to_pos(x), height-yoffset+2);
      }
    } else {
      ctx.strokeStyle = 'rgb(0, 0, 0)';
      for (var x=Math.ceil(xmin/xstep)*xstep; x <= xmax; x += xstep) {
        ctx.strokeText(x, x_val_to_pos(x), height-yoffset+2);
      }
    }


    for (var y=Math.floor(ymax/ystep)*ystep; y >= ymin; y -= ystep) {
      ctx.strokeStyle = 'rgb(100, 100, 100)';
      ctx.beginPath();
      ctx.moveTo(x_val_to_pos(xmin), y_val_to_pos(y));
      ctx.lineTo(x_val_to_pos(xmax), y_val_to_pos(y));
      ctx.stroke();
    }
    if (logx) {
      var xbase = Math.pow(10, Math.floor(Math.log10(xmin)));
      var x = Math.ceil(xmin / xbase) * xbase;
      ctx.strokeStyle = 'rgb(100, 100, 100)';
      while (x <= xmax) {
        ctx.beginPath();
        var xc = x_val_to_pos(x);
        ctx.moveTo(xc, y_val_to_pos(ymax));
        ctx.lineTo(xc, y_val_to_pos(ymin));
        ctx.stroke();
        x += xbase;
        if (x >= 9.99 * xbase) {
          xbase *= 10;
        }
      }
    } else {
      for (var x=Math.ceil(xmin/xstep)*xstep; x <= xmax; x += xstep) {
        ctx.beginPath();
        var xc = x_val_to_pos(x);
        ctx.moveTo(xc, y_val_to_pos(ymax));
        ctx.lineTo(xc, y_val_to_pos(ymin));
        ctx.stroke();
      }
    }
    ctx.rect(x_val_to_pos(xmin), y_val_to_pos(ymin), x_val_to_pos(xmax)-x_val_to_pos(xmin), y_val_to_pos(ymax)-y_val_to_pos(ymin));
    ctx.stroke();
  }

  fgctx.rect(xoffset, 10, width-xoffset, height-yoffset-10);
  fgctx.clip();

  var drawData = function(xdata, ydata) {
    fgctx.clearRect(0, 0, width, height);
    fgctx.strokeStyle = 'rgb(0, 0, 0)';
    fgctx.beginPath();
    fgctx.moveTo(x_val_to_pos(xdata[0]), y_val_to_pos(ydata[0]));
    for (var i = 1; i < ydata.length; i++) {
      fgctx.lineTo(x_val_to_pos(xdata[i]), y_val_to_pos(ydata[i]));
    }
    fgctx.stroke();
  }

  return {
    drawData: drawData,
    xlim: function(_xmin, _xmax) {
      xmin = _xmin;
      xmax = _xmax;
      drawAxis();
    },
    ylim: function(_ymin, _ymax) {
      ymin = _ymin;
      ymax = _ymax;
      drawAxis();
    },
    logx: function(_logx) {
      set_logx(_logx);
    },
  }
};

var graph = makeFunctionGraph("axiscanvas", "funccanvas");
graph.ylim(-130, 0);

var setupAudio = function(oninit, onended) {
  var audioCtx = new (window.AudioContext || window.webkitAudioContext)({latencyHint: "playback"});

  var source;
  var gain;
  var analyzer = audioCtx.createAnalyser();
  analyzer.smoothingTimeConstant = 0.3;
  analyzer.minDecibels = -130;
  var timeDomainData = new Float32Array(analyzer.fftSize);
  var frequencyDomainData = new Float32Array(analyzer.frequencyBinCount);
  analyzer.connect(audioCtx.destination);
  var proc;

  audioCtx.audioWorklet.addModule('qdsproc.js').then(() => {
    proc = new AudioWorkletNode(audioCtx, 'qds-processor');

    for (var p of ['w', "dither", 'dithertype', 'noiseshaping', 'noiseshapingfilter']) {
      (function(p) {
        Object.defineProperty(proc, p, {
          set: function(val) {
            proc.port.postMessage({param: p, value: val});
          }
        });
      })(p);
    }

    oninit();
  });

  var start = function(src) {
    if (source !== undefined) {
      source.disconnect();
      source = undefined;
    }
    if (gain !== undefined) {
      gain.disconnect();
      gain = undefined;
    }
    audioCtx.resume();
    if (src instanceof AudioBuffer) {
      source = audioCtx.createBufferSource();
      source.buffer = src;
      source.onended = function() {
        stop();
        onended();
      }
      source.start();
      source.connect(proc);
    } else {
      source = audioCtx.createOscillator();
      source.type = "sine";
      source.start();
      gain = audioCtx.createGain();
      gain.gain.value = 0.5;
      source.connect(gain);
      gain.connect(proc);
    }
    proc.connect(analyzer);
  }

  var stop = function() {
    if (source !== undefined) {
      source.disconnect();
      source = undefined;
    }
    if (gain !== undefined) {
      gain.disconnect();
      gain = undefined;
    }
    proc.disconnect();
    audioCtx.suspend();
  }

  var getTimeDomainData = function() {
    analyzer.getFloatTimeDomainData(timeDomainData);
    return timeDomainData;
  }

  var getFrequencyDomainData = function() {
    analyzer.getFloatFrequencyData(frequencyDomainData);
    return frequencyDomainData;
  }

  return {
    start: start,
    stop: stop,
    isPlaying: function () {
      return source !== undefined;
    },
    createBuffer: function(contents, onSuccess) {
      audioCtx.decodeAudioData(contents, onSuccess);
    },
    getTimeDomainData: getTimeDomainData,
    getFrequencyDomainData: getFrequencyDomainData,
    proc: function() { return proc; },
  }
};

function updatePlayButtonStates() {
  if (audioProc.isPlaying()) {
    document.getElementById("audio1").disabled = true;
    document.getElementById("audio2").disabled = true;
    document.getElementById("start").disabled = true;
    document.getElementById("file-input").disabled = true;
    document.getElementById("stop").disabled = false;
  } else {
    document.getElementById("audio1").disabled = audio2data === undefined;
    document.getElementById("audio2").disabled = false;
    document.getElementById("start").disabled = audioFileData === undefined;
    document.getElementById("file-input").disabled = false;
    document.getElementById("stop").disabled = true;
  }
}

function initproc() {
  audioProc.proc().w = 16;
  audioProc.proc().dither = true;
  audioProc.proc().dithertype = "rect";
  audioProc.proc().noiseshaping = true;
  audioProc.proc().noiseshapingfilter = 1;
}

var audioProc = setupAudio(initproc, updatePlayButtonStates);

var audio2data;
var audioFileData;
var request = new XMLHttpRequest();
request.open('GET', 'audio/unfinite_function.mp3', true);
request.responseType = 'arraybuffer';
request.onload = function() {
  audioProc.createBuffer(request.response, function(buf) {
    audio2data = buf;
    updatePlayButtonStates();
  });
}
request.send();

var frequencies = new Float32Array(audioProc.getFrequencyDomainData());
for (var i = 0; i < frequencies.length; i++) {
  frequencies[i] = i * 22050 / (frequencies.length-1);
}
var timeindices = new Float32Array(audioProc.getTimeDomainData());
for (var i = 0; i < timeindices.length; i++) {
  timeindices[i] = i;
}
var drawWave = false;
function drawSignal() {
  requestAnimationFrame(drawSignal);
  if (drawWave) {
    var data = audioProc.getTimeDomainData();
    graph.drawData(timeindices, data);
  } else {
    var data = audioProc.getFrequencyDomainData();
    graph.drawData(frequencies, data);
  }
}
drawSignal();

function updatePlayButtonStates() {
  if (audioProc.isPlaying()) {
    document.getElementById("audio1").disabled = true;
    document.getElementById("audio2").disabled = true;
    document.getElementById("start").disabled = true;
    document.getElementById("file-input").disabled = true;
    document.getElementById("stop").disabled = false;
  } else {
    document.getElementById("audio1").disabled = false;
    document.getElementById("audio2").disabled = audio2data === undefined;
    document.getElementById("start").disabled = audioFileData === undefined;
    document.getElementById("file-input").disabled = false;
    document.getElementById("stop").disabled = true;
  }
}

document.getElementById("audio1").onclick = function(event) {
  audioProc.start();
  updatePlayButtonStates();
}
document.getElementById("audio2").onclick = function(event) {
  audioProc.start(audio2data);
  updatePlayButtonStates();
}
document.getElementById("start").onclick = function(event) {
  audioProc.start(audioFileData);
  updatePlayButtonStates();
}
document.getElementById("stop").onclick = function(event) {
  audioProc.stop();
  updatePlayButtonStates();
}
document.getElementById('file-input').addEventListener('change', function (e) {
  var file = e.target.files[0];
  if (!file) {
    return;
  }
  var reader = new FileReader();
  reader.onload = function(e) {
    var contents = e.target.result;
    audioProc.createBuffer(contents, function(buf) {
      audioFileData = buf;
      audioProc.start(audioFileData);
      updatePlayButtonStates();
    });
  };
  reader.readAsArrayBuffer(file);}, false);

updatePlayButtonStates();


var cblinear = document.getElementById("linear");
cblinear.checked = false;
graph.logx(true);
cblinear.onchange = function (event) {
  if (!document.getElementById("wave").checked) {
    graph.logx(!event.target.checked);
  }
};
var cbwave = document.getElementById("wave");
cbwave.checked = false;
cbwave.onchange = function (event) {
  drawWave = event.target.checked;
  if (drawWave) {
    graph.logx(false);
    graph.ylim(-1, 1);
    graph.xlim(0, timeindices.length-1);
  } else {
    graph.xlim(50, 20000);
    graph.logx(!cblinear.checked);
    graph.ylim(-130, 0);
  }
};
document.getElementById("wordlength").value = 16;
document.getElementById("wordlength").onchange = function (event) {
  audioProc.proc().w = event.target.value;
};
function updateDiagram() {
  if (document.getElementById("dither").checked) {
    if (document.getElementById("noiseshaping").checked) {
      document.getElementById("diagram").src = "images/qds/ns5.png";
    } else {
      document.getElementById("diagram").src = "images/qds/ns5b.png";
    }
  } else {
    if (document.getElementById("noiseshaping").checked) {
      document.getElementById("diagram").src = "images/qds/ns5c.png";
    } else {
      document.getElementById("diagram").src = "images/qds/ns5d.png";
    }
  }
}
document.getElementById("dither").checked = true;
document.getElementById("dither").onchange = function (event) {
  audioProc.proc().dither = event.target.checked;
  updateDiagram();
};
document.getElementById("noiseshaping").checked = true;
document.getElementById("noiseshaping").onchange = function (event) {
  audioProc.proc().noiseshaping = event.target.checked;
  updateDiagram();
};
document.getElementById("dithertype").value = "rect";
document.getElementById("dithertype").onchange = function (event) {
  audioProc.proc().dithertype = event.target.value;
};
document.getElementById("noiseshapingfilter").value = 1;
document.getElementById("noiseshapingfilter").onchange = function (event) {
  audioProc.proc().noiseshapingfilter = event.target.value;
};
</script>
</body>
</html>
